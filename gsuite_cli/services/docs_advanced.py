"""
Advanced Google Docs service with enhanced features
"""

import logging
from typing import List, Dict, Any, Optional
from datetime import datetime
import json

from googleapiclient.errors import HttpError

from ..auth.oauth import OAuthManager
from ..utils.formatters import print_error, print_success, print_info
from ..utils.cache import ServiceCache

logger = logging.getLogger(__name__)


class AdvancedDocsService:
    """Advanced Google Docs service with templates, collaboration, and more"""
    
    def __init__(self, oauth_manager: OAuthManager, cache_manager=None):
        self.oauth_manager = oauth_manager
        self.docs_service = None
        self.drive_service = None
        self.cache = ServiceCache('docs_advanced', cache_manager) if cache_manager else None
        self._initialize_services()
        
        # Document templates
        self.templates = {
            'meeting': {
                'title': 'Meeting Notes - {date}',
                'content': '''# Meeting Notes - {date}

## Attendees
- 
- 
- 

## Agenda
1. 
2. 
3. 

## Discussion Points

### Topic 1
- Key points:
- Decisions:
- Action items:

### Topic 2
- Key points:
- Decisions:
- Action items:

## Action Items
| Task | Owner | Due Date | Status |
|------|-------|----------|--------|
|      |       |          |        |

## Next Meeting
- Date: 
- Time: 
- Location: 

## Notes
'''
            },
            'project': {
                'title': 'Project Plan - {project_name}',
                'content': '''# Project Plan - {project_name}

## Project Overview
**Project Name:** {project_name}
**Start Date:** {date}
**Project Manager:** 
**Team Members:** 

## Objectives
- 
- 
- 

## Scope
### In Scope
- 
- 
- 

### Out of Scope
- 
- 
- 

## Timeline
| Phase | Start Date | End Date | Deliverables |
|-------|------------|----------|-------------|
| Planning | | | |
| Development | | | |
| Testing | | | |
| Deployment | | | |

## Resources
### Human Resources
- 
- 
- 

### Technical Resources
- 
- 
- 

## Risks & Mitigation
| Risk | Probability | Impact | Mitigation Strategy |
|------|-------------|---------|-------------------|
|      |             |         |                   |
|      |             |         |                   |

## Budget
| Category | Estimated Cost | Actual Cost | Variance |
|----------|----------------|-------------|----------|
|          |                |             |          |
|          |                |             |          |

## Communication Plan
- **Stakeholder Meetings:** 
- **Progress Reports:** 
- **Escalation Process:** 

## Success Criteria
- 
- 
- 

---
*Last Updated: {date}*
'''
            },
            'report': {
                'title': 'Report - {title}',
                'content': '''# {title}

**Report Date:** {date}
**Prepared by:** 
**Period:** 

## Executive Summary


## Key Findings


## Detailed Analysis


## Recommendations


## Conclusion


## Appendices

---
*Generated by GSuite CLI*
'''
            },
            'todo': {
                'title': 'Todo List - {date}',
                'content': '''# Todo List - {date}

## High Priority
- [ ] 
- [ ] 
- [ ] 

## Medium Priority
- [ ] 
- [ ] 
- [ ] 

## Low Priority
- [ ] 
- [ ] 
- [ ] 

## Completed
- [x] 
- [x] 
- [x] 

## Notes


---
*Stay productive!*
'''
            }
        }
    
    def _initialize_services(self) -> bool:
        """Initialize the Docs and Drive services"""
        try:
            self.docs_service = self.oauth_manager.build_service('docs', 'v1')
            self.drive_service = self.oauth_manager.build_service('drive', 'v3')
            return self.docs_service is not None and self.drive_service is not None
        except Exception as e:
            logger.error(f"Failed to initialize Docs services: {e}")
            return False
    
    def create_from_template(self, template_type: str, title: str = None, **kwargs) -> Optional[str]:
        """Create document from template"""
        if template_type not in self.templates:
            print_error(f"Template '{template_type}' not found. Available: {list(self.templates.keys())}")
            return None
        
        template = self.templates[template_type]
        
        # Generate title
        if title:
            doc_title = title
        else:
            doc_title = template['title'].format(
                date=datetime.now().strftime('%Y-%m-%d'),
                **kwargs
            )
        
        # Generate content
        content = template['content'].format(
            date=datetime.now().strftime('%Y-%m-%d'),
            **kwargs
        )
        
        # Create document
        try:
            doc = self.docs_service.documents().create(body={
                'title': doc_title
            }).execute()
            
            document_id = doc.get('documentId')
            
            # Add content
            if content:
                self.update_document(document_id, content)
            
            # Invalidate cache
            if self.cache:
                self.cache.invalidate('list_documents')
            
            print_success(f"Created '{doc_title}' from {template_type} template")
            print_info(f"Document ID: {document_id}")
            
            return document_id
        except HttpError as e:
            logger.error(f"Failed to create document from template: {e}")
            print_error(f"Failed to create document: {e}")
            return None
    
    def update_document(self, document_id: str, content: str) -> bool:
        """Update document content"""
        if not self.docs_service:
            return False
        
        try:
            # Get current document structure
            doc = self.docs_service.documents().get(documentId=document_id).execute()
            
            # Clear existing content and add new content
            requests = [
                {
                    'deleteContentRange': {
                        'range': {
                            'startIndex': 1,
                            'endIndex': doc.get('body', {}).get('content', [])[-1].get('endIndex', -1)
                        }
                    }
                },
                {
                    'insertText': {
                        'location': {
                            'index': 1
                        },
                        'text': content
                    }
                }
            ]
            
            # Execute updates
            self.docs_service.documents().batchUpdate(
                documentId=document_id,
                body={'requests': requests}
            ).execute()
            
            # Invalidate cache
            if self.cache:
                self.cache.invalidate('get_document', document_id)
            
            return True
        except HttpError as e:
            logger.error(f"Failed to update document {document_id}: {e}")
            return False
    
    def get_document_with_metadata(self, document_id: str) -> Optional[Dict[str, Any]]:
        """Get document with full metadata and analytics"""
        if not self.docs_service or not self.drive_service:
            return None
        
        # Try cache first
        if self.cache:
            cached_result = self.cache.get('get_document_with_metadata', document_id)
            if cached_result is not None:
                return cached_result
        
        try:
            # Get document content
            doc = self.docs_service.documents().get(documentId=document_id).execute()
            
            # Get file metadata
            file = self.drive_service.files().get(
                fileId=document_id,
                fields="name, createdTime, modifiedTime, size, owners, permissions, webViewLink, sharingUser"
            ).execute()
            
            # Get revision history
            revisions = self.drive_service.revisions().list(
                fileId=document_id,
                fields="revisions(id, modifiedTime, lastModifyingUser, kind)"
            ).execute()
            
            # Extract text content
            content = self._extract_text_from_doc(doc)
            
            # Advanced analytics
            analytics = self._analyze_document_content(content)
            
            formatted_doc = {
                'id': document_id,
                'name': file.get('name'),
                'content': content,
                'created': file.get('createdTime'),
                'modified': file.get('modifiedTime'),
                'size': file.get('size', '0'),
                'owners': [owner.get('displayName', 'Unknown') for owner in file.get('owners', [])],
                'shared': len(file.get('permissions', [])) > 1,
                'web_view_link': file.get('webViewLink'),
                'sharing_user': file.get('sharingUser', {}).get('displayName'),
                'revisions_count': len(revisions.get('revisions', [])),
                'last_revision': revisions.get('revisions', [])[-1] if revisions.get('revisions') else None,
                'analytics': analytics,
                'collaborators': self._get_collaborators(file.get('permissions', []))
            }
            
            # Cache the result
            if self.cache:
                self.cache.set('get_document_with_metadata', formatted_doc, 600, document_id)
            
            return formatted_doc
        except HttpError as e:
            logger.error(f"Failed to get document metadata {document_id}: {e}")
            return None
    
    def _analyze_document_content(self, content: str) -> Dict[str, Any]:
        """Analyze document content for insights"""
        if not content:
            return {}
        
        lines = content.split('\n')
        words = content.split()
        paragraphs = [p for p in lines if p.strip()]
        
        # Count different elements
        headers = sum(1 for line in lines if line.startswith('#'))
        lists = sum(1 for line in lines if line.strip().startswith(('-', '*', '+')))
        checkboxes = sum(1 for line in lines if '[ ]' in line or '[x]' in line)
        
        # Reading time estimation (average 200 words per minute)
        reading_time = max(1, len(words) // 200)
        
        # Complexity score (based on structure)
        complexity_score = min(100, (headers * 10) + (lists * 5) + (checkboxes * 3))
        
        return {
            'word_count': len(words),
            'char_count': len(content),
            'line_count': len(lines),
            'paragraph_count': len(paragraphs),
            'header_count': headers,
            'list_count': lists,
            'checkbox_count': checkboxes,
            'estimated_reading_time_minutes': reading_time,
            'complexity_score': complexity_score,
            'content_type': self._detect_content_type(content, headers, lists, checkboxes)
        }
    
    def _detect_content_type(self, content: str, headers: int, lists: int, checkboxes: int) -> str:
        """Detect the type of document content"""
        content_lower = content.lower()
        
        if checkboxes > 5:
            return 'Todo List'
        elif 'meeting' in content_lower or 'agenda' in content_lower or 'attendees' in content_lower:
            return 'Meeting Notes'
        elif 'project' in content_lower and 'timeline' in content_lower:
            return 'Project Plan'
        elif 'report' in content_lower or 'executive summary' in content_lower:
            return 'Report'
        elif headers > 10:
            return 'Structured Document'
        elif lists > 10:
            return 'List-based Document'
        else:
            return 'General Document'
    
    def _get_collaborators(self, permissions: List[Dict]) -> List[Dict[str, Any]]:
        """Extract collaborator information from permissions"""
        collaborators = []
        
        for permission in permissions:
            if permission.get('type') in ['user', 'group']:
                collaborator = {
                    'name': permission.get('displayName', 'Unknown'),
                    'email': permission.get('emailAddress', ''),
                    'role': permission.get('role', 'reader'),
                    'type': permission.get('type', 'user')
                }
                collaborators.append(collaborator)
        
        return collaborators
    
    def share_document(self, document_id: str, email: str, role: str = 'reader') -> bool:
        """Share document with another user"""
        if not self.drive_service:
            return False
        
        try:
            permission = {
                'type': 'user',
                'role': role,
                'emailAddress': email
            }
            
            self.drive_service.permissions().create(
                fileId=document_id,
                body=permission,
                sendNotificationEmail=True
            ).execute()
            
            # Invalidate cache
            if self.cache:
                self.cache.invalidate('get_document_with_metadata', document_id)
            
            print_success(f"Document shared with {email} as {role}")
            return True
        except HttpError as e:
            logger.error(f"Failed to share document {document_id}: {e}")
            print_error(f"Failed to share document: {e}")
            return False
    
    def get_document_versions(self, document_id: str) -> List[Dict[str, Any]]:
        """Get document version history"""
        if not self.drive_service:
            return []
        
        try:
            revisions = self.drive_service.revisions().list(
                fileId=document_id,
                fields="revisions(id, modifiedTime, lastModifyingUser, kind, size)"
            ).execute()
            
            versions = []
            for rev in revisions.get('revisions', []):
                version = {
                    'id': rev.get('id'),
                    'modified_time': rev.get('modifiedTime'),
                    'modifier': rev.get('lastModifyingUser', {}).get('displayName', 'Unknown'),
                    'size': rev.get('size', '0'),
                    'kind': rev.get('kind')
                }
                versions.append(version)
            
            return versions
        except HttpError as e:
            logger.error(f"Failed to get document versions: {e}")
            return []
    
    def export_document_advanced(self, document_id: str, format: str = 'pdf') -> Optional[str]:
        """Export document in various formats"""
        if not self.drive_service:
            return None
        
        # Map format to MIME type
        mime_types = {
            'pdf': 'application/pdf',
            'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            'txt': 'text/plain',
            'html': 'text/html',
            'rtf': 'application/rtf',
            'odt': 'application/vnd.oasis.opendocument.text'
        }
        
        mime_type = mime_types.get(format.lower())
        if not mime_type:
            print_error(f"Unsupported format: {format}. Supported: {list(mime_types.keys())}")
            return None
        
        try:
            data = self.drive_service.files().export(
                fileId=document_id,
                mimeType=mime_type
            ).execute()
            
            if isinstance(data, bytes):
                return data.decode('utf-8', errors='ignore')
            return data
        except HttpError as e:
            logger.error(f"Failed to export document: {e}")
            print_error(f"Failed to export document: {e}")
            return None
    
    def duplicate_document(self, document_id: str, new_title: str = None) -> Optional[str]:
        """Duplicate a document"""
        if not self.drive_service:
            return None
        
        try:
            # Get original file info
            file = self.drive_service.files().get(
                fileId=document_id,
                fields="name, parents"
            ).execute()
            
            # Create copy
            copy_metadata = {
                'name': new_title or f"Copy of {file.get('name')}",
                'parents': file.get('parents', [])
            }
            
            copy = self.drive_service.files().copy(
                fileId=document_id,
                body=copy_metadata
            ).execute()
            
            new_document_id = copy.get('id')
            
            # Invalidate cache
            if self.cache:
                self.cache.invalidate('list_documents')
            
            print_success(f"Document duplicated: {copy_metadata['name']}")
            print_info(f"New Document ID: {new_document_id}")
            
            return new_document_id
        except HttpError as e:
            logger.error(f"Failed to duplicate document: {e}")
            print_error(f"Failed to duplicate document: {e}")
            return None
    
    def list_templates(self) -> Dict[str, Dict[str, str]]:
        """List available templates"""
        return {
            name: {
                'title': template['title'],
                'description': self._get_template_description(name)
            }
            for name, template in self.templates.items()
        }
    
    def _get_template_description(self, template_name: str) -> str:
        """Get description for a template"""
        descriptions = {
            'meeting': 'Professional meeting notes with agenda, action items, and follow-ups',
            'project': 'Comprehensive project plan with timeline, resources, and risk management',
            'report': 'Structured report template with executive summary and recommendations',
            'todo': 'Organized todo list with priority levels and tracking'
        }
        return descriptions.get(template_name, 'Custom template')
    
    def _extract_text_from_doc(self, doc: Dict[str, Any]) -> str:
        """Extract plain text from document structure"""
        content = []
        
        def extract_from_structural_elements(elements):
            for element in elements:
                if 'paragraph' in element:
                    paragraph = element['paragraph']
                    for para_element in paragraph.get('elements', []):
                        if 'textRun' in para_element:
                            content.append(para_element['textRun'].get('content', ''))
                elif 'table' in element:
                    table = element['table']
                    for row in table.get('tableRows', []):
                        for cell in row.get('tableCells', []):
                            for cell_element in cell.get('content', []):
                                extract_from_structural_elements([cell_element])
        
        body_content = doc.get('body', {}).get('content', [])
        extract_from_structural_elements(body_content)
        
        return ''.join(content).strip()
